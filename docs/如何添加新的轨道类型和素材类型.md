# 如何添加新的轨道类型和素材类型

本文档说明在 `pyJianYingDraft` 项目中添加新的轨道类型和素材类型时需要修改的代码位置和步骤。

---

## 目录

1. [添加新轨道类型](#1-添加新轨道类型)
2. [添加新素材类型](#2-添加新素材类型)
3. [在服务端支持新类型](#3-在服务端支持新类型)
4. [完整示例](#4-完整示例)
5. [测试检查清单](#5-测试检查清单)

---

## 1. 添加新轨道类型

### 1.1 在 `TrackType` 枚举中添加新类型

**文件**: `pyJianYingDraft/track.py`

**位置**: `TrackType` 类定义

```python
class TrackType(Enum):
    """轨道类型枚举"""

    video = Track_meta(VideoSegment, 0, True)
    audio = Track_meta(AudioSegment, 0, True)
    effect = Track_meta(EffectSegment, 10000, False)
    filter = Track_meta(FilterSegment, 11000, False)
    sticker = Track_meta(StickerSegment, 14000, False)
    text = Track_meta(TextSegment, 15000, True)

    # ↓ 添加新轨道类型 ↓
    # new_track = Track_meta(NewSegment, render_index, allow_modify)
```

**参数说明**:
- `NewSegment`: 对应的片段类(需要先创建,见下文)
- `render_index`: 渲染层级,值越大越靠前景
  - `0`: 主轨道层(video, audio)
  - `10000+`: 特效层
  - `14000+`: 文本/贴纸层
- `allow_modify`: 是否允许在模板模式下修改
  - `True`: 可修改轨道(会创建为 `ImportedMediaTrack` 或 `ImportedTextTrack`)
  - `False`: 只读轨道(会创建为 `ImportedTrack`)

**示例**:
```python
# 添加一个新的"蒙版"轨道类型
mask = Track_meta(MaskSegment, 12000, False)
```

### 1.2 创建对应的 Segment 类(如果需要)

**文件**: 根据功能创建新文件,如 `pyJianYingDraft/mask_segment.py`

**基类选择**:
- 继承 `BaseSegment`: 基础片段类
- 继承 `VideoSegment`: 如果需要视频相关功能
- 继承 `EffectSegment`: 如果是特效类

**示例**:
```python
from pyJianYingDraft.segment import BaseSegment
from pyJianYingDraft.time_util import Timerange

class MaskSegment(BaseSegment):
    """蒙版片段"""

    def __init__(self, mask_path: str, target_timerange: Timerange, **kwargs):
        self.mask_path = mask_path
        super().__init__(target_timerange, **kwargs)

    def export_json(self) -> dict:
        """导出为JSON格式"""
        data = super().export_json()
        data.update({
            "mask_path": self.mask_path,
            # 其他字段...
        })
        return data
```

### 1.3 在 `import_track` 函数中添加处理逻辑(可选)

**文件**: `pyJianYingDraft/template_mode.py`

**位置**: `import_track` 函数

如果新轨道类型需要特殊的导入逻辑:

```python
def import_track(json_data: Dict[str, Any]) -> ImportedTrack:
    """导入轨道"""
    track_type = TrackType.from_name(json_data["type"])

    if not track_type.value.allow_modify:
        return ImportedTrack(json_data)

    if track_type == TrackType.text:
        return ImportedTextTrack(json_data)

    # ↓ 添加新轨道类型的特殊处理 ↓
    # if track_type == TrackType.mask:
    #     return ImportedMaskTrack(json_data)

    return ImportedMediaTrack(json_data)
```

---

## 2. 添加新素材类型

### 2.1 素材类型识别常量

**文件**: `pyJianYingDraftServer/app/services/rule_test_service.py`

**位置**: `RuleTestService` 类的常量定义

```python
class RuleTestService:
    """执行规则测试并生成剪映草稿"""

    DEFAULT_WIDTH = 1920
    DEFAULT_HEIGHT = 1080
    DEFAULT_FPS = 30

    AUDIO_TYPES = {"audio", "music", "sound", "extract_music"}
    TEXT_TYPES = {"text", "subtitle"}

    # ↓ 添加新素材类型集合 ↓
    # MASK_TYPES = {"mask", "layer_mask", "clipping_mask"}
```

### 2.2 在 `_infer_track_type` 方法中添加推断逻辑

**文件**: `pyJianYingDraftServer/app/services/rule_test_service.py`

**位置**: `_infer_track_type` 静态方法

```python
@staticmethod
def _infer_track_type(material: MaterialPayload) -> str:
    extra = material.model_extra or {}
    material_type = (material.type or extra.get("material_type") or "video").lower()

    if material_type in RuleTestService.AUDIO_TYPES:
        return "audio"
    if material_type in RuleTestService.TEXT_TYPES:
        return "text"
    # 检查是否包含 "effect" 或 "filter" 关键字
    if "effect" in material_type or "filter" in material_type:
        return "effect"
    if material_type in {"sticker"}:
        return "sticker"

    # ↓ 添加新素材类型的推断逻辑 ↓
    # if material_type in RuleTestService.MASK_TYPES:
    #     return "mask"

    return "video"
```

**推断策略**:
1. **精确匹配**: 使用集合判断 `material_type in TYPES`
2. **关键字匹配**: 使用子字符串判断 `"keyword" in material_type`
3. **默认后备**: 返回 `"video"` 作为默认值

### 2.3 在 `material_category_map` 中添加映射

**文件**: `pyJianYingDraftServer/app/services/rule_test_service.py`

**位置**: `_clone_segment_with_materials` 方法中的 `material_category_map`

```python
# 后备方案:使用轨道类型的第一个material作为模板
# 注意:effect轨道可能包含video_effects或effects两种category的素材
material_category_map = {
    "audio": "audios",
    "video": "videos",
    "text": "stickers",
    "video_effect": "video_effects",
    "sticker": "stickers",
    "effect": "video_effects",  # effect轨道优先使用video_effects

    # ↓ 添加新类型的映射 ↓
    # "mask": "masks",
}
target_category = material_category_map.get(track_type, "videos")
```

**映射说明**:
- **Key**: 轨道类型名称(字符串)
- **Value**: 在 `materials` 字典中的 category 名称
- 如果轨道类型可能对应多个 category,选择最常用的作为默认

---

## 3. 在服务端支持新类型

### 3.1 更新 Material 素材分类枚举(可选)

如果需要在剪映的 `materials` 结构中添加新的分类:

**文件**: 剪映草稿的 `draft_content.json` 结构

**位置**: `materials` 对象

```json
{
  "materials": {
    "videos": [],
    "audios": [],
    "texts": [],
    "effects": [],
    "video_effects": [],

    // ↓ 添加新的素材分类 ↓
    "masks": []
  }
}
```

### 3.2 在 `_build_segment` 方法中添加处理逻辑(如果需要特殊处理)

**文件**: `pyJianYingDraftServer/app/services/rule_test_service.py`

**位置**: `_build_segment` 静态方法

```python
@staticmethod
def _build_segment(material: MaterialPayload, item_data: Dict[str, Any]):
    start = float(item_data.get("start", 0.0))
    material_type = RuleTestService._infer_material_kind(material)
    path = ...

    duration_value = RuleTestService._resolve_duration_seconds(...)
    timerange = draft.trange(f"{start}s", f"{duration_value}s")

    if material_type in RuleTestService.AUDIO_TYPES:
        # 音频处理...
        return draft.AudioSegment(...)

    if material_type in RuleTestService.TEXT_TYPES:
        # 文本处理...
        return draft.TextSegment(...)

    # ↓ 添加新类型的特殊处理 ↓
    # if material_type in RuleTestService.MASK_TYPES:
    #     mask_path = item_data.get("mask_path") or path
    #     return draft.MaskSegment(mask_path, timerange)

    # 默认视频处理
    clip = RuleTestService._build_clip_settings(item_data, style_hint)
    volume = RuleTestService._resolve_volume(item_data, style_hint)
    return draft.VideoSegment(path, timerange, volume=volume, clip_settings=clip)
```

---

## 4. 完整示例:添加"蒙版(Mask)"轨道类型

假设我们要添加一个新的"蒙版"轨道类型,支持图片蒙版和视频蒙版。

### 4.1 创建 Segment 类

**文件**: `pyJianYingDraft/mask_segment.py` (新建)

```python
from typing import Optional
from pyJianYingDraft.segment import BaseSegment
from pyJianYingDraft.time_util import Timerange

class MaskSegment(BaseSegment):
    """蒙版片段"""

    def __init__(
        self,
        mask_path: str,
        target_timerange: Timerange,
        *,
        invert: bool = False,
        feather: float = 0.0,
        opacity: float = 1.0,
        **kwargs
    ):
        """
        Args:
            mask_path: 蒙版文件路径
            target_timerange: 片段在时间轴上的时间范围
            invert: 是否反转蒙版
            feather: 羽化强度(0-1)
            opacity: 不透明度(0-1)
        """
        self.mask_path = mask_path
        self.invert = invert
        self.feather = feather
        self.opacity = opacity
        super().__init__(target_timerange, **kwargs)

    def export_json(self) -> dict:
        """导出为JSON格式"""
        data = super().export_json()
        data.update({
            "mask_path": self.mask_path,
            "invert": self.invert,
            "feather": self.feather,
            "opacity": self.opacity,
        })
        return data
```

**导出到包**: 在 `pyJianYingDraft/__init__.py` 中添加:

```python
from pyJianYingDraft.mask_segment import MaskSegment
```

### 4.2 添加到 TrackType 枚举

**文件**: `pyJianYingDraft/track.py`

```python
class TrackType(Enum):
    """轨道类型枚举"""

    video = Track_meta(VideoSegment, 0, True)
    audio = Track_meta(AudioSegment, 0, True)
    effect = Track_meta(EffectSegment, 10000, False)
    filter = Track_meta(FilterSegment, 11000, False)
    mask = Track_meta(MaskSegment, 12000, False)  # ← 新增
    sticker = Track_meta(StickerSegment, 14000, False)
    text = Track_meta(TextSegment, 15000, True)
    adjust = Track_meta(None, 0, False)
```

### 4.3 服务端支持

**文件**: `pyJianYingDraftServer/app/services/rule_test_service.py`

#### 添加常量
```python
class RuleTestService:
    AUDIO_TYPES = {"audio", "music", "sound", "extract_music"}
    TEXT_TYPES = {"text", "subtitle"}
    MASK_TYPES = {"mask", "layer_mask", "alpha_mask"}  # ← 新增
```

#### 添加推断逻辑
```python
@staticmethod
def _infer_track_type(material: MaterialPayload) -> str:
    extra = material.model_extra or {}
    material_type = (material.type or extra.get("material_type") or "video").lower()

    if material_type in RuleTestService.AUDIO_TYPES:
        return "audio"
    if material_type in RuleTestService.TEXT_TYPES:
        return "text"
    if "effect" in material_type or "filter" in material_type:
        return "effect"
    if material_type in RuleTestService.MASK_TYPES:  # ← 新增
        return "mask"
    if material_type in {"sticker"}:
        return "sticker"

    return "video"
```

#### 添加 category 映射
```python
material_category_map = {
    "audio": "audios",
    "video": "videos",
    "text": "stickers",
    "video_effect": "video_effects",
    "sticker": "stickers",
    "effect": "video_effects",
    "mask": "masks",  # ← 新增
}
```

#### 添加 segment 构建逻辑
```python
@staticmethod
def _build_segment(material: MaterialPayload, item_data: Dict[str, Any]):
    start = float(item_data.get("start", 0.0))
    material_type = RuleTestService._infer_material_kind(material)
    path = ...

    duration_value = RuleTestService._resolve_duration_seconds(...)
    timerange = draft.trange(f"{start}s", f"{duration_value}s")

    if material_type in RuleTestService.AUDIO_TYPES:
        return draft.AudioSegment(...)

    if material_type in RuleTestService.TEXT_TYPES:
        return draft.TextSegment(...)

    if material_type in RuleTestService.MASK_TYPES:  # ← 新增
        invert = item_data.get("invert", False)
        feather = item_data.get("feather", 0.0)
        opacity = item_data.get("opacity", 1.0)
        return draft.MaskSegment(
            path, timerange,
            invert=invert,
            feather=feather,
            opacity=opacity
        )

    # 默认视频处理
    clip = RuleTestService._build_clip_settings(item_data, style_hint)
    volume = RuleTestService._resolve_volume(item_data, style_hint)
    return draft.VideoSegment(path, timerange, volume=volume, clip_settings=clip)
```

---

## 5. 测试检查清单

添加新类型后,需要测试以下场景:

### 5.1 基础功能测试

- [ ] **枚举识别**: `TrackType.from_name("new_type")` 能正确返回枚举
- [ ] **Segment 创建**: 能创建新类型的 segment 实例
- [ ] **导出 JSON**: `segment.export_json()` 返回正确的 JSON 结构
- [ ] **添加到草稿**: `script.add_segment(segment)` 能正确添加

### 5.2 服务端测试

- [ ] **类型推断**: `_infer_track_type` 能正确识别素材类型
- [ ] **轨道创建**: 生成的草稿包含正确类型的轨道
- [ ] **素材分类**: materials 中包含正确的 category
- [ ] **Segment 构建**: `_build_segment` 能正确创建 segment

### 5.3 模板模式测试

- [ ] **模板加载**: `add_raw_segments` 能加载包含新类型的模板
- [ ] **模板收集**: `segment_templates_by_type` 包含新类型
- [ ] **模板匹配**: 能找到对应的 segment 模板
- [ ] **素材克隆**: `_clone_segment_with_materials` 能正确克隆

### 5.4 剪映验证

- [ ] **草稿打开**: 生成的草稿能在剪映中正常打开
- [ ] **轨道显示**: 轨道在时间轴上正确显示
- [ ] **效果预览**: 效果在预览窗口正确显示
- [ ] **导出视频**: 能正常导出包含新类型的视频

---

## 6. 常见问题

### Q1: 新轨道类型的 `allow_modify` 应该设置为 `True` 还是 `False`?

**A**: 根据功能决定:
- **`True`**: 如果需要在模板模式下修改 segment 内容(如替换素材、调整时间)
- **`False`**: 如果轨道是特效/滤镜类,不需要修改 segment 内容

### Q2: 如何处理有多个 material category 的轨道类型?

**A**: 在 `material_category_map` 中选择最常用的 category 作为默认值。如果需要支持多个:

```python
# 方案1: 在 _clone_segment_with_materials 中添加特殊逻辑
if track_type == "effect":
    # 优先查找 video_effects, 后备 effects
    target_category = "video_effects"
    if target_category not in original_materials:
        target_category = "effects"
```

### Q3: 新类型的 segment 需要实现哪些方法?

**A**: 必须实现:
- `__init__`: 构造函数
- `export_json`: 导出为 JSON 格式

可选实现:
- `__str__`, `__repr__`: 方便调试
- 其他业务方法

### Q4: 如何支持新类型的关键帧/动画?

**A**: 参考 `VideoSegment` 的实现:
1. 添加关键帧属性(如 `alpha_keyframes`, `transform_keyframes`)
2. 在 `export_json` 中导出关键帧数据
3. 添加便捷方法(如 `add_alpha_keyframe`)

---

## 7. 参考文档

- **轨道类型定义**: `pyJianYingDraft/track.py`
- **Segment 基类**: `pyJianYingDraft/segment.py`
- **服务端逻辑**: `pyJianYingDraftServer/app/services/rule_test_service.py`
- **模板模式**: `pyJianYingDraft/template_mode.py`
- **剪映草稿格式**: `CLAUDE.md` 中的"草稿文件结构"章节

---

## 8. 版本历史

| 版本 | 日期 | 变更说明 |
|------|------|----------|
| 1.0 | 2025-01-28 | 初始版本 |

---

**维护者**: pyJianYingDraft 开发团队
**最后更新**: 2025-01-28
